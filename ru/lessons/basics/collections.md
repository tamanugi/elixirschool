---
version: 1.2.5
title: Коллекции
---

Списки, кортежи, ключевые списки и ассоциативные массивы.

{% include toc.html %}

## Списки
Списки &mdash; это обычные коллекции значений. Они могут включать различные типы и неуникальные значения.

```elixir
iex> [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
```

Списки в Elixir являются односвязными.
Это означает, что получение длины списка имеет линейную сложность (`O(n)`).
По этой причине добавлять элементы в начало списка намного быстрее, чем в конец.

```elixir
iex> list = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
# Добавление в начало списка (быстро)
iex> ["π" | list]
["π", 3.14, :pie, "Apple"]
# Добавление в конец списка (медленно)
iex> list ++ ["Cherry"]
[3.14, :pie, "Apple", "Cherry"]
```

### Объединение списков

Для объединения списков используется оператор `++/2`:

```elixir
iex> [1, 2] ++ [3, 4, 1]
[1, 2, 3, 4, 1]
```

Небольшая заметка по поводу формата имён (`++/2`), использованного выше: в Elixir (и Erlang, на основе которого сделан Elixir) имена функций и операторов состоят из двух частей: непосредственно имени (в этом случае `++`) и _арности_. Арность &mdash; одно из ключевых понятий Elixir и Erlang. Это количество аргументов, принимаемых функцией (в этом случае два). Арность и имя соединены через слэш. Позже мы разберём это подробнее.

### Вычитание списков

Оператор `--/2` предоставляет возможность вычитать списки. Не будет ошибкой вычитание отсутствующего элемента:

```elixir
iex> ["foo", :bar, 42] -- [42, "bar"]
["foo", :bar]
```

Обратите внимание на повторяющиеся значения. Из левого списка удаляется только первое вхождение каждого элемента правого списка:

```elixir
iex> [1,2,2,3,2,3] -- [1,2,3,2]
[2, 3]
```

**Замечание:** Для сопоставления элементов используется [строгое сравнение](../basics#section-11). Например:

```elixir
iex> [2] -- [2.0]
[2]
iex> [2.0] -- [2.0]
[]
```

### Голова / Хвост

При использовании списков очень частой операцией является получение "головы" и "хвоста" списка.
"Головой" является первый элемент, а "хвостом" &mdash; остальные элементы.
Для работы с ними Elixir предоставляет два оператора &mdash; `hd` и `tl`:

```elixir
iex> hd [3.14, :pie, "Apple"]
3.14
iex> tl [3.14, :pie, "Apple"]
[:pie, "Apple"]
```

Того же результата можно добиться с использованием оператора cons &mdash; `|`. Мы будем часто его встречать в последующих уроках.

```elixir
iex> [head | tail] = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
iex> head
3.14
iex> tail
[:pie, "Apple"]
```

## Кортежи

Кортежи похожи на списки, но хранятся в памяти последовательно.
Это даёт возможность быстро получить определенный элемент и длину кортежа. Но изменения становятся "дорогими", так как для этого создаваемый кортеж должен быть целиком скопирован в новую область памяти.
Кортежи определяются с помощью фигурных скобок:

```elixir
iex> {3.14, :pie, "Apple"}
{3.14, :pie, "Apple"}
```

Часто они используются как механизм для получения дополнительной информации из функций. Полезность этого будет видна позже, когда мы будем углубляться в [сопоставление с образцом](../pattern-matching/):

```elixir
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

## Ключевые списки

Ключевые списки и ассоциативные массивы являются имплементациями ассоциативных коллекций в Elixir.
В Elixir ключевые списки &mdash; это специальные списки из двухэлементных кортежей, первым элементом которых является атом. По скорости они идентичны спискам.

```elixir
iex> [foo: "bar", hello: "world"]
[foo: "bar", hello: "world"]
iex> [{:foo, "bar"}, {:hello, "world"}]
[foo: "bar", hello: "world"]
```

Три характеристики этой структуры данных показывают её важность:

+ Ключи являются атомами.
+ Ключи имеют свой порядок.
+ Ключи необязательно должны быть уникальными.

Поэтому она часто используется для передачи параметров в функции.

## Ассоциативные массивы

В Elixir ассоциативный массив &mdash; это хранилище типа ключ-значение с возможностью быстрого получения информации по ключу.
В отличие от ключевых списков, они поддерживают любой тип ключей и не сохраняют порядок следования. Ассоциативный массив объявляется с помощью синтаксиса `%{}`:

```elixir
iex> map = %{:foo => "bar", "hello" => :world}
%{:foo => "bar", "hello" => :world}
iex> map[:foo]
"bar"
iex> map["hello"]
:world
```

С версии Elixir 1.2 переменные поддерживаются в качестве ключей:

```elixir
iex> key = "hello"
"hello"
iex> %{key => "world"}
%{"hello" => "world"}
```

Если в эту структуру данных добавляется новый ключ, он перепишет старое значение:

```elixir
iex> %{:foo => "bar", :foo => "hello world"}
%{foo: "hello world"}
```

Как видно из вывода команды выше, также есть специальный короткий синтаксис для ассоциативных массивов, ключами которых являются только атомы:

```elixir
iex> %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}

iex> %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
true
```

Также существует специальный синтаксис для получения значений ключей-атомов:

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> map.hello
"world"
```

Ещё одно интересное свойство ассоциативных массивов &mdash; это особенный синтаксис для обновления:

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> %{map | foo: "baz"}
%{foo: "baz", hello: "world"}
```
